<?php
/**
 * This script generates boilerplate for:
 * - A JSON-format Storybook file for use with @storybook/server-webpack5
 * - An example output rendering file
 * It uses the component JSON definitions generated by generate-json-defs.php to do this.
 * If the file already exists, it will not be overwritten unless you add the --overwrite flag to the end of the command.
 * NOTE: This script requires PHP 8.4+.
 *
 * Usage: php scripts/generate-stories.php to generate all
 *        php scripts/generate-stories.php --component MyComponent to generate stories for a specific component
 *        php scripts/generate-stories.php --component MyComponent --overwrite to regenerate existing stories for a specific component and overwrite existing ones
 */

class ComponentStoryGenerator {
	private string $sourceDirectory;
	private string $testComponentDirectory;
	private bool $overwrite;

	public function __construct($overwrite = false) {
		$this->sourceDirectory = dirname(__DIR__, 1) . '\packages\core\src\components';
		$this->overwrite = $overwrite ?? false;
	}

	public function runAll(): void {
		// Get all JSON files in the directory
		/** @noinspection PhpUnhandledExceptionInspection */
		$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->sourceDirectory));

		foreach($files as $file) {
			if($file->isFile() && $file->getExtension() === 'json') {
				$this->testComponentDirectory = dirname($file->getPathname(), 2) . '/__tests__';
				$this->processFile($file->getPathname());
			}
		}
	}

	/** @noinspection PhpUnhandledExceptionInspection */
	public function runSingle($component): void {
		// Ensure JSON definition file exists
		// Selectively allow stories for some inner components
		if($component === 'File') {
			$filePath = $this->sourceDirectory . '\\FileGroup\\File\\__docs__\\File.json';
		}
		// Otherwise, look for main component JSON files
		else {
			$filePath = $this->sourceDirectory . '\\' . $component . '\\__docs__\\' . $component . '.json';
		}
		if(!file_exists($filePath)) {
			throw new RuntimeException("Component class $component not found");
		}

		// Ensure tests directory exists in the component directory and create it if it doesn't
		if(!file_exists($this->sourceDirectory . '\\' . $component . '\\' . '__tests__')) {
			mkdir($this->sourceDirectory . '\\' . $component . '\\' . '/__tests__', 0777, true);
		}

		$this->testComponentDirectory = $this->sourceDirectory . '\\' . $component . '\\' . '/__tests__';
		$this->processFile($filePath);
	}

	private function processFile(string $filePath): void {
		// Read JSON from the definition file
		$content = file_get_contents($filePath);
		$json = json_decode($content, true);
		$shortName = self::kebab_case($json['name']);
		// Exclude some attributes handled internally , not suitable for Storybook, or not suitable to autogenerate
		$attributes = array_diff_key($json['attributes'], array_flip(['id', 'style', 'context']));
		if(in_array($shortName, ['container', 'group', 'site-header', 'site-footer'])) {
			$category = 'Structure';
		}
		else if(isset($json['extends'])) {
			$category = str_replace('Component', '', $json['extends']);
		}
		// Otherwise, get the category from the WordPress plugin's block support JSON file
		else {
			$category = ucfirst(self::get_category_from_wordpress_plugin_json($json['name'])) ?? 'Uncategorised';
		}

		// Determine tags from the various JSON files:
		// 1. Values in the component's JSON file
		$tags = [];
		if(isset($json['vue']) && $json['vue'] === true) {
			array_push($tags, 'vue');
		}
		// 2. Is this a custom WordPress block? As determined by presence of a matching directory in packages/comet-plugin/src/blocks
		$blockJsonPath = dirname(__DIR__, 1) . "/packages/comet-plugin/src/blocks/$shortName";
		if(file_exists($blockJsonPath)) {
			array_push($tags, 'wordpress-block');
		}
		// 3. Is this a supported WordPress core block?
		$blockSupportJson = json_decode(file_get_contents(dirname(__DIR__, 1) . '/packages/comet-plugin/src/block-support.json'), true);
		if(isset($blockSupportJson['core']['supported']['core/' . $shortName])) {
			array_push($tags, 'wordpress-block');
		}
		// Note: The above tag logic doesn't cover 100% of cases, such as renamed blocks and plugin blocks; a small number will need tags manually added

		$this->generateComponentOutputPage($json['name'], $shortName, $attributes);
		$this->generateStoryFile($json['name'], $shortName, $attributes, $category, $tags);
	}

	private function generateComponentOutputPage($name, $shortName, $attributes): void {
		// If the test file already exists, bail unless the overwrite flag is set
		if(file_exists("$this->testComponentDirectory/$shortName.php") && !$this->overwrite) {
			$this->log("Browser output example file already exists for $name, skipping\n", 'info');
			return;
		}

		$namespacedName = 'Doubleedesign\Comet\Core\\' . $name;
		$attributeKeys = implode(', ', array_map(function($key) {
			return "'{$key}'";  // Add single quotes around each key
		}, array_keys($attributes)));

		// TODO: If the component extends TextElement, use a basic string instead of mock inner components
		$fileContent = <<<EOT
		<?php
		use $namespacedName;
		use Doubleedesign\Comet\Core\{Paragraph};
		
		// Attribute keys from component JSON definition
		\$attributeKeys = [$attributeKeys];
		// Filter the request query vars to only those matching the above
		\$attributes = array_filter(\$_REQUEST, fn(\$key) => in_array(\$key, \$attributeKeys), ARRAY_FILTER_USE_KEY);
		// Make true and false strings proper booleans
		\$attributes = array_map(fn(\$value) => \$value === 'true' ? true : (\$value === 'false' ? false : \$value), \$attributes);
		// Filter out any attributes that are empty or false
		\$attributes = array_filter(\$attributes, function(\$value) {
			return \$value !== '' && \$value !== 'false' && \$value !== 'none' && \$value !== 'null';
		});
		
		\$innerComponents = [new Paragraph([], '$shortName component')];
		
		\$component = new $name(\$attributes, \$innerComponents);
		\$component->render();
		EOT;

		// Write to file
		$outputPath = "$this->testComponentDirectory/$shortName.php";
		file_put_contents($outputPath, $fileContent);
	}

	private function generateStoryFile($name, $shortName, $attributes, $category, $tags): void {
		// If the story file already exists, bail unless the overwrite flag is set
		if(file_exists("$this->sourceDirectory\\$name\\__tests__\\$shortName.stories.json") && !$this->overwrite) {
			$this->log("Storybook file already exists for $name, skipping\n", 'info');
			return;
		}

		$storyFile = [
			'title'      => sprintf('%s/%s', $category, $name),
			'tags'       => $tags,
			'parameters' => [
				'server' => [
					"id"     => self::kebab_case($shortName) . '.php',
					'url'    => sprintf('/packages/core/src/components/%s/__tests__', $name),
					'params' => [
						"__debug" => true
					]
				]
			]
		];

		$argsOrder = [
			'content',
			'innerComponents',
			'tagName',
			'size',
			'breakpoint',
			'allowStacking',
			'orientation',
			'hAlign',
			'vAlign',
			'colorTheme',
			'isOutline',
			'backgroundColor',
			'gradient',
			'iconPrefix',
			'icon',
			'href',
			'url',
			'target',
			'classes',
			'testId'
		];

		$storyFile['args'] = array_reduce(array_keys($attributes), function($acc, $attr) use ($attributes) {
			// Do not show a specified class name by default (the auto-generated ones within the component will still be where they need to be)
			if($attr === 'classes') return $acc;

			$acc[$attr] = $attributes[$attr]['default'] ?? '';
			return $acc;
		}, []);
		// Sort the args based on the specified order by key
		uksort($storyFile['args'], function($a, $b) use ($argsOrder) {
			$aIndex = array_search($a, $argsOrder);
			$bIndex = array_search($b, $argsOrder);
			if($aIndex === false && $bIndex === false) return 0;
			if($aIndex === false) return 1;
			if($bIndex === false) return -1;
			return $aIndex <=> $bIndex;
		});

		$storyFile ['argTypes'] = array_reduce(array_keys($attributes), function($acc, $attr) use ($attributes) {
			// Special handling for classes - include "supported" values but not the default or generated classes
			// This allows auto-generation of options like "accent heading" and "lead paragraph" without also including BEM classnames and the like
			if($attr === 'classes' && isset($attributes[$attr]['supported'])) {
				$acc['class'] = [
					'description' => $attributes[$attr]['description'] ?? '',
					'control'     => ['type' => 'select'],
					'options'     => ['', ...$attributes[$attr]['supported']],
					'table'       => [
						'defaultValue' => ['summary' => ''],
						'type'         => ['summary' => 'string']
					]
				];

				return $acc;
			}

			$data = $attributes[$attr];
			$propType = isset($data['supported']) ? 'array' : $data['type'];

			// Don't show any options for gradient type because I haven't put in any default/built-in options yet
			// This is also how to handle any attribute we want to show in the table but without control options or input
			if($attr === 'gradient') {
				$acc[$attr] = [
					'description' => $data['description'] ?? '',
					'control'     => false,
					'table'       => [
						'defaultValue' => [
							'summary' => $data['default'] ?? ''
						],
						'type'         => [
							'summary' => $data['type']
						]
					]
				];

				return $acc;
			}

			$showControl = true;
			$noConrol = ['classes', 'gradient', 'testId'];
			if(in_array($attr, $noConrol)) {
				$showControl = false;
			}
			$noOfOptions = isset($data['supported']) ? count($data['supported']) : 1;
			if($noOfOptions < 2) {
				$showControl = false;
			}

			$acc[$attr] = [
				'description' => $data['description'] ?? '',
				'control'     => $showControl ? ['type' => self::propertyTypeToControl($propType)] : false,
				'table'       => [
					'defaultValue' => [
						'summary' => $data['default'] ?? ''
					],
					'type'         => [
						'summary' => $data['type']
					]
				]
			];

			if($propType === 'array' && isset($data['supported'])) {
				$acc[$attr]['options'] = $data['supported'];
			}

			return $acc;
		}, []);
		// Sort the argTypes based on the specified order by key
		uksort($storyFile['argTypes'], function($a, $b) use ($argsOrder) {
			// Sort the argTypes based on the specified order
			$aIndex = array_search($a, $argsOrder);
			$bIndex = array_search($b, $argsOrder);

			if($aIndex === false && $bIndex === false) return 0;
			if($aIndex === false) return 1;
			if($bIndex === false) return -1;

			return $aIndex <=> $bIndex;
		});

		$stories = [
			[
				'name' => 'Playground',
				'args' => [],
				'tags' => ['docsOnly']
			]
		];

		// Remove this if re-adding the below functionality to generate multiple stories
		$storyFile['stories'] = $stories;

		// Collect boolean attributes to generate variations for each of the options
		$booleanAttributes = array_filter($attributes, function($attr) {
			return $attr['type'] === 'bool';
		});

		// Skip generating individual stories for now
//		// Components to skip generating further stories for (they are to be done manually, or not at all for whatever reason)
//		$skip = ['Container', 'Columns', 'Column', 'Group', 'Banner', 'SiteHeader'];
//		if(in_array($name, $skip)) {
//			$storyFile['stories'] = $stories;
//		}
//		else {
//			foreach($storyFile['argTypes'] as $propName => $settings) {
//				// Common properties that we don't want individual stories for
//				if(in_array($propName, ['tagName', 'classes', 'backgroundColor', 'textAlign'])) continue;
//
//				// Generate stories for properties with options specified
//				if(!isset($settings['options'])) continue;
//
//				foreach($settings['options'] as $option) {
//					// Adjust label for "is-style-*" class names
//					$displayName = $option;
//					if(str_starts_with($option, 'is-style-')) {
//						$displayName = substr($option, 9) . ' style';
//					}
//					$stories[] = [
//						'name' => ucfirst($propName) . ': ' . ucfirst($displayName),
//						'args' => [
//							$propName => $option
//						]
//					];
//
//					if(!empty($booleanAttributes)) {
//						foreach($booleanAttributes as $boolAttrName => $boolAttrSettings) {
//							$boolAttrDisplayName = $boolAttrName;
//							// Adjust label for things like "isOutline" be "Outline" etc
//							if(str_starts_with($boolAttrName, 'is')) {
//								$boolAttrDisplayName = substr($boolAttrName, 2);
//							}
//
//							$stories[] = [
//								'name' => ucfirst($option) . ' - ' . $boolAttrDisplayName,
//								'args' => [
//									$propName     => $option,
//									$boolAttrName => true
//								]
//							];
//						}
//					}
//				}
//			}
//			$storyFile['stories'] = array_values(array_filter($stories, function($story) {
//				return !empty($story['name']);
//			}));
//		}

		// Export the processed data as a JSON file
		$outputPath = $this->sourceDirectory . '\\' . $name . '\\__tests__\\' . strtolower($shortName) . '.stories.json';
		$this->exportToJson($outputPath, $storyFile);
	}

	/**
	 * Exports the processed data as a JSON file to the specified output path.
	 * @param string $outputPath Where to save the file.
	 * @param array $data The array of data to be encoded into JSON and exported.
	 *
	 * @return void
	 */
	public function exportToJson(string $outputPath, array $data): void {
		$json = json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
		try {
			file_put_contents($outputPath, $json);
			$this->log("Exported to $outputPath\n", 'success');
		}
		catch(Exception $e) {
			$this->log("Failed to export to $outputPath: {$e->getMessage()}\n", 'error');
		}
	}

	private static function propertyTypeToControl($propType): string {
		return match ($propType) {
			'number' => 'number',
			'bool' => 'boolean',
			'array', 'Tag', 'Alignment', 'AspectRatio' => 'select',
			default => 'text',
		};
	}

	private static function kebab_case(string $value): string {
		// Account for PascalCase
		$value = preg_replace('/([a-z])([A-Z])/', '$1 $2', $value);

		// Convert whitespace to hyphens and make lowercase
		return trim(strtolower(preg_replace('/\s+/', '-', $value)));
	}

	private static function get_description_from_wordpress_block_json($block_name): string {
		if($block_name === 'ButtonGroup') {
			$block_name = 'buttons';
		}

		// Look for my blocks first
		$cometBlocksDir = dirname(__DIR__, 1) . '/packages/comet-plugin/src/blocks';
		$blockJsonPath = $cometBlocksDir . '/' . $block_name . '/block.json';
		if(file_exists($blockJsonPath)) {
			$blockJson = json_decode(file_get_contents($blockJsonPath), true);
			return $blockJson['description'];
		}

		// Then core block description overrides from the WordPress plugin
		$json = json_decode(file_get_contents(dirname(__DIR__, 1) . '/packages/comet-plugin/src/block-support.json'), true);
		if(isset($json['core']['supported']['core/' . strtolower($block_name)])) {
			$customDescription = $json['core']['supported']['core/' . strtolower($block_name)]['description'] ?? null;
			if(isset($customDescription)) {
				return $customDescription;
			}
		}

		$coreBlocksDir = dirname(__DIR__, 1) . '/wordpress/wp-includes/blocks'; // WP installed as Composer dependency
		$blockJsonPath = $coreBlocksDir . '/' . $block_name . '/block.json';
		if(file_exists($blockJsonPath)) {
			$blockJson = json_decode(file_get_contents($blockJsonPath), true);
			return $blockJson['description'];
		}

		return '';
	}

	private static function get_category_from_wordpress_plugin_json($block_name): string {
		$json = file_get_contents(dirname(__DIR__, 1) . '/packages/comet-plugin/src/block-support.json');
		$categories = json_decode($json, true)['categories'];

		return array_find($categories, function($category) use ($block_name) {
			$block_name_kebab = self::kebab_case($block_name);
			if($block_name_kebab === 'button-group') {
				$block_name_kebab = 'buttons';
			}
			return in_array("comet/$block_name_kebab", $category['blocks']) || in_array("core/$block_name_kebab", $category['blocks']);
		})['name'] ?? 'Uncategorised';
	}

	private static function move_default_to_top(array $items): array {
		usort($items, function($a, $b) {
			if($a === 'default') return -1;
			if($b === 'default') return 1;

			return 0;
		});

		return $items;
	}

	private static function log(string $message, string $type): void {
		// ANSI colour codes
		$red = "\033[0;31m";
		$green = "\033[0;32m";
		$yellow = "\033[0;33m";
		$cyan = "\033[0;36m";
		$white = "\033[0;37m";
		$reset = "\033[0m";

		$color = match ($type) {
			'info' => $cyan,
			'success' => $green,
			'error' => $red,
			'warning' => $yellow,
			default => $white,
		};

		echo $color . $message . $reset;
	}
}


// Usage: php generate-stories.php
//     or php generate-stories.php --component MyComponent
try {
	$overwrite = isset($argv[3]) && $argv[3] === '--overwrite';
	$instance = new ComponentStoryGenerator($overwrite);
	if(isset($argv[1]) && $argv[1] === '--component') {
		$instance->runSingle($argv[2]);
	}
	else {
		$instance->runAll();
	}
}
catch(Exception $e) {
	echo "Error: " . $e->getMessage() . "\n";
}
