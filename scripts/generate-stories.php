<?php
/**
 * This script generates boilerplate for:
 * - A JSON-format Storybook file for use with @storybook/server-webpack5 in ./test/browser/stories
 * - An example output rendering file in ./test/browser/components
 * It uses the component JSON definitions generated by generate-json-defs.php to do this.
 * If the file already exists, it will not be overwritten unless you add the --overwrite flag to the end of the command.
 * NOTE: This script requires PHP 8.4+.
 *
 * Usage: php scripts/generate-stories.php to generate all
 *        php scripts/generate-stories.php --component MyComponent to generate stories for a specific component
 *        php scripts/generate-stories.php --component MyComponent --overwrite to regenerate existing stories for a specific component and overwrite existing ones
 */

class ComponentStoryGenerator {
	private string $sourceDirectory;
	private string $testComponentDirectory;
	private bool $overwrite;

	public function __construct($overwrite = false) {
		$this->sourceDirectory = dirname(__DIR__, 1) . '\packages\core\src\components';
		$this->testComponentDirectory = dirname(__DIR__, 1) . '\test\browser\components';
		$this->overwrite = $overwrite ?? false;
	}

	public function runAll(): void {
		// Get all JSON files in the directory
		/** @noinspection PhpUnhandledExceptionInspection */
		$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->sourceDirectory));

		foreach($files as $file) {
			if($file->isFile() && $file->getExtension() === 'json') {
				$this->processFile($file->getPathname());
			}
		}
	}

	/** @noinspection PhpUnhandledExceptionInspection */
	public function runSingle($component): void {
		// Ensure JSON definition file exists
		$filePath = $this->sourceDirectory . '\\' . $component . '\\' . $component . '.json';
		if(!file_exists($filePath)) {
			throw new RuntimeException("Component class $component not found");
		}

		// Ensure tests directory exists in the component directory and create it if it doesn't
		if(!file_exists($this->sourceDirectory . '\\' . $component . '\\' . '__tests__')) {
			mkdir($this->sourceDirectory . '\\' . $component . '\\' . '/__tests__', 0777, true);
		}

		$this->processFile($filePath);
	}

	private function processFile(string $filePath): void {
		// Read JSON from the file
		$content = file_get_contents($filePath);
		$json = json_decode($content, true);
		$shortName = self::kebab_case($json['name']);
		// Exclude some attributes handled internally , not suitable for Storybook, or not suitable to autogenerate
		$attributes = array_diff_key($json['attributes'], array_flip(['id', 'style', 'context']));
		// Get the category from the WordPress plugin's block support JSON file
		$category = ucfirst(self::get_category_from_wordpress_plugin_json($json['name'])) ?? 'Uncategorised';

		$this->generateComponentOutputPage($json['name'], $shortName, $attributes);
		$this->generateStoryFile($json['name'], $shortName, $attributes, $category);
	}

	private function generateComponentOutputPage($name, $shortName, $attributes): void {
		// If the file already exists, bail unless the overwrite flag is set
		if(file_exists("$this->testComponentDirectory/$shortName.php") && !$this->overwrite) {
			print_r("Browser output example file already exists for $name, skipping\n");
			return;
		}

		$namespacedName = 'Doubleedesign\Comet\Core\\' . $name;
		$attributeKeys = implode(', ', array_map(function($key) {
			return "'{$key}'";  // Add single quotes around each key
		}, array_keys($attributes)));

		// TODO: If the component extends TextElement, use a basic string instead of mock inner components
		$fileContent = <<<EOT
		<?php
		use $namespacedName;
		use const Doubleedesign\Comet\TestUtils\MOCK_INNER_COMPONENTS_BLOCK_OF_TEXT;
		
		// Attribute keys fetched from component JSON definition
		\$attributeKeys = [$attributeKeys];
		// Filter the request query vars to only those matching the above
		\$attributes = array_filter(\$_REQUEST, fn(\$key) => in_array(\$key, \$attributeKeys), ARRAY_FILTER_USE_KEY);
		
		\$innerComponents = MOCK_INNER_COMPONENTS_BLOCK_OF_TEXT;
		
		\$component = new $name(\$attributes, \$innerComponents);
		\$component->render();
		EOT;

		// Write to file
		$outputPath = "$this->testComponentDirectory/$shortName.php";
		file_put_contents($outputPath, $fileContent);
	}

	private function generateStoryFile($name, $shortName, $attributes, $category): void {
		// If the file already exists, bail unless the overwrite flag is set
		if(file_exists("$this->sourceDirectory/__tests__/$shortName.stories.json") && !$this->overwrite) {
			print_r("Storybook file already exists for $name, skipping\n");
			return;
		}

		$storyFile = [
			'title'      => sprintf('Components/%s/%s', $category, $name),
			'parameters' => [
				'docs'   => [
					"description" => [
						"component" => self::get_description_from_wordpress_block_json($name)
					]
				],
				'server' => [
					"id"     => $shortName,
					'url'    => sprintf('http://localhost:6001/components/%s.php', strtolower($shortName)),
					'params' => [
						"__debug" => true
					]
				]
			]
		];

		$storyFile['args'] = array_reduce(array_keys($attributes), function($acc, $attr) use ($attributes) {
			// Do not show a specified class name by default (the auto-generated ones within the component will still be where they need to be)
			if($attr === 'classes') return $acc;

			$acc[$attr] = $attributes[$attr]['default'] ?? '';
			return $acc;
		}, []);

		$storyFile['argTypes'] = array_reduce(array_keys($attributes), function($acc, $attr) use ($attributes) {
			// Special handling for classes - include "supported" values but not the default or generated classes
			// This allows auto-generation of options like "accent heading" and "lead paragraph" without also including BEM classnames and the like
			if($attr === 'classes' && isset($attributes[$attr]['supported'])) {
				$acc['class'] = [
					'description' => $attributes[$attr]['description'] ?? '',
					'control'     => ['type' => 'select'],
					'options'     => ['', ...$attributes[$attr]['supported']],
					'table'       => [
						'defaultValue' => ['summary' => ''],
						'type'         => ['summary' => 'string']
					]
				];

				return $acc;
			}

			$data = $attributes[$attr];
			$propType = isset($data['supported']) ? 'array' : $data['type'];

			// Don't show any options for gradient type because I haven't put in any default/built-in options yet
			// This is also how to handle any attribute we want to show in the table but without control options or input
			if($attr === 'gradient') {
				$acc[$attr] = [
					'description' => $data['description'] ?? '',
					'control'     => 'none',
					'table'       => [
						'defaultValue' => [
							'summary' => $data['default'] ?? ''
						],
						'type'         => [
							'summary' => $data['type']
						]
					]
				];

				return $acc;
			}

			$acc[$attr] = [
				'description' => $data['description'] ?? '',
				'control'     => $attr === 'classes' ? false : ['type' => self::propertyTypeToControl($propType)],
				'table'       => [
					'defaultValue' => [
						'summary' => $data['default'] ?? ''
					],
					'type'         => [
						'summary' => $data['type']
					]
				]
			];

			if($propType === 'array' && isset($data['supported'])) {
				$acc[$attr]['options'] = $data['supported'];
			}

			return $acc;
		}, []);

		$stories = [
			[
				'name' => 'Playground',
				'args' => [],
				'tags' => ['docsOnly']
			]
		];

		// Collect boolean attributes to generate variations for each of the options
		$booleanAttributes = array_filter($attributes, function($attr) {
			return $attr['type'] === 'bool';
		});

		// Components to skip generating stories for (they are to be done manually, or not at all for whatever reason)
		$skip = ['Container', 'Columns', 'Column', 'Group', 'Banner'];
		if(in_array($name, $skip)) {
			$storyFile['stories'] = $stories;
		}
		else {
			foreach($storyFile['argTypes'] as $propName => $settings) {
				// Common properties that we don't want individual stories for
				if(in_array($propName, ['tagName', 'classes', 'backgroundColor', 'textAlign'])) continue;

				// Generate stories for properties with options specified
				if(!isset($settings['options'])) continue;

				foreach($settings['options'] as $option) {
					// Adjust label for "is-style-*" class names
					$displayName = $option;
					if(str_starts_with($option, 'is-style-')) {
						$displayName = substr($option, 9) . ' style';
					}
					$stories[] = [
						'name' => ucfirst($propName) . ': ' . ucfirst($displayName),
						'args' => [
							$propName => $option
						]
					];

					if(!empty($booleanAttributes)) {
						foreach($booleanAttributes as $boolAttrName => $boolAttrSettings) {
							$boolAttrDisplayName = $boolAttrName;
							// Adjust label for things like "isOutline" be "Outline" etc
							if(str_starts_with($boolAttrName, 'is')) {
								$boolAttrDisplayName = substr($boolAttrName, 2);
							}

							$stories[] = [
								'name' => ucfirst($option) . ' - ' . $boolAttrDisplayName,
								'args' => [
									$propName     => $option,
									$boolAttrName => true
								]
							];
						}
					}
				}
			}
			$storyFile['stories'] = array_values(array_filter($stories, function($story) {
				return !empty($story['name']);
			}));
		}

		// Export the processed data as a JSON file
		$outputPath = $this->sourceDirectory . '\\' . $name . '\\__tests__\\' . strtolower($shortName) . '.stories.json';
		$this->exportToJson($outputPath, $storyFile);
	}

	/**
	 * Exports the processed data as a JSON file to the specified output path.
	 * @param string $outputPath Where to save the file.
	 * @param array $data The array of data to be encoded into JSON and exported.
	 *
	 * @return void
	 */
	public function exportToJson(string $outputPath, array $data): void {
		$json = json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
		file_put_contents($outputPath, $json);
	}

	private static function propertyTypeToControl($propType): string {
		return match ($propType) {
			'number' => 'number',
			'bool' => 'boolean',
			'array', 'Tag', 'Alignment', 'AspectRatio' => 'select',
			default => 'text',
		};
	}

	private static function kebab_case(string $value): string {
		// Account for PascalCase
		$value = preg_replace('/([a-z])([A-Z])/', '$1 $2', $value);

		// Convert whitespace to hyphens and make lowercase
		return trim(strtolower(preg_replace('/\s+/', '-', $value)));
	}

	private static function get_description_from_wordpress_block_json($block_name): string {
		if($block_name === 'ButtonGroup') {
			$block_name = 'buttons';
		}

		// Look for my blocks first
		$cometBlocksDir = dirname(__DIR__, 1) . '/packages/comet-plugin/src/blocks';
		$blockJsonPath = $cometBlocksDir . '/' . $block_name . '/block.json';
		if(file_exists($blockJsonPath)) {
			$blockJson = json_decode(file_get_contents($blockJsonPath), true);
			return $blockJson['description'];
		}

		// Then core block description overrides from the WordPress plugin
		$json = json_decode(file_get_contents(dirname(__DIR__, 1) . '/packages/comet-plugin/src/block-support.json'));
		$customDescription = $json->core->supported->{'core/' . strtolower($block_name)}->description;
		if(isset($customDescription)) {
			return $customDescription;
		}

		$coreBlocksDir = dirname(__DIR__, 1) . '/wordpress/wp-includes/blocks'; // WP installed as Composer dependency
		$blockJsonPath = $coreBlocksDir . '/' . $block_name . '/block.json';
		if(file_exists($blockJsonPath)) {
			$blockJson = json_decode(file_get_contents($blockJsonPath), true);
			return $blockJson['description'];
		}

		return '';
	}

	private static function get_category_from_wordpress_plugin_json($block_name): string {
		$json = file_get_contents(dirname(__DIR__, 1) . '/packages/comet-plugin/src/block-support.json');
		$categories = json_decode($json, true)['categories'];

		return array_find($categories, function($category) use ($block_name) {
			$block_name_kebab = self::kebab_case($block_name);
			if($block_name_kebab === 'button-group') {
				$block_name_kebab = 'buttons';
			}
			return in_array("comet/$block_name_kebab", $category['blocks']) || in_array("core/$block_name_kebab", $category['blocks']);
		})['name'] ?? 'Uncategorised';
	}

	private static function move_default_to_top(array $items): array {
		usort($items, function($a, $b) {
			if($a === 'default') return -1;
			if($b === 'default') return 1;

			return 0;
		});

		return $items;
	}
}


// Usage: php generate-stories.php
//     or php generate-stories.php --component MyComponent
try {
	$overwrite = isset($argv[3]) && $argv[3] === '--overwrite';
	$instance = new ComponentStoryGenerator($overwrite);
	if(isset($argv[1]) && $argv[1] === '--component') {
		$instance->runSingle($argv[2]);
	}
	else {
		$instance->runAll();
	}
	echo "Done!\n";
}
catch(Exception $e) {
	echo "Error: " . $e->getMessage() . "\n";
}
